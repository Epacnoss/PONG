import tableclass bat:    def __init__(self, table, w=15, h=15, xPos=50, yPos=50, colour="green", xSpd=23, ySpd=23):        self.w = w        self.h = h        self.x = xPos        self.y = yPos        self.c = colour        self.xStart = xPos        self.yStart = yPos        self.xSpd = xSpd        self.ySpd = ySpd        self.table = table        self.rect = self.table.drawRect(self)    def moveUp(self, master):        self.y -= self.ySpd        if self.y <= 0:            self.y = 0        x1 = self.x        x2 = x1 + self.w        y1 = self.y        y2 = y1 + self.h        self.table.moveItem(self.rect, x1, y1, x2, y2)    def moveDown(self, master):        self.y += self.ySpd        if self.y >= self.table.h - self.h:            self.y = self.table.h - self.h        x1 = self.x        x2 = x1 + self.w        y1 = self.y        y2 = y1 + self.h        self.table.moveItem(self.rect, x1, y1, x2, y2)    def moveLeft(self, master):        self.x -= self.xSpd        farRight = self.table.w - self.w        if self.x <= 0:            self.x = 0        x1 = self.x        x2 = x1 + self.w        y1 = self.y        y2 = y1 + self.h        self.table.moveItem(self.rect, x1, y1, x2, y2)    def moveRight(self, master):        self.x += self.xSpd        farRight = self.table.w - self.w        if self.x >= farRight:            self.x = farRight        x1 = self.x        x2 = x1 + self.w        y1 = self.y        y2 = y1 + self.h        self.table.moveItem(self.rect, x1, y1, x2, y2)    def startPos(self):        self.x = self.xStart        self.y = self.yStart    def detectCollision(self, ball, sideSweetSpot=True, topSweetSpot=False):        collisionDir = "miss"        collided = False        feel = 1        #Bat Vars        top = self.y        bottom = top + self.h        left = self.x        right = left + self.w        vCentre = top + (self.h / 2)        hCentre = top + (self.w / 2)        #Ball Vars        topB = ball.y        bottomB = topB + ball.h        leftB = ball.x        rightB = leftB + ball.w        r = (rightB - leftB) / 2  # radius        vCentreB = topB + r        hCentreB = leftB + r        if bottomB > top and topB < bottom and rightB > left and leftB < right:            collided = True            print("Collision")        if collided:            if topB > top-r and bottomB > bottom+r and rightB > right >= leftB:                collisionDir = "E"                ball.xSpd = abs(ball.xSpd)            elif leftB > left-r and rightB < right+r and bottomB > bottom >= topB:                collisionDir = "S"                ball.ySpd = abs(ball.ySpd)            elif leftB < left-r and rightB < right+r and topB > top and bottomB >= top:                collisionDir = "N"                ball.ySpd = -abs(ball.ySpd)            elif topB > top-r and bottomB < bottom+r and leftB < left <= rightB:                collisionDir = "W"                ball.xSpd = -abs(ball.xSpd)            # if sideSweetSpot and (collisionDir == "W" or collisionDir == "E"):            #     adj = (-(vCentre - vCentreB)) / (self.h / 2)            #     ball.ySpd = feel * adj            # if topSweetSpot and (collisionDir == "N" or collisionDir == "S"):            #     adj = (-(hCentre - hCentreB)) / (self.w / 2)            #     ball.xSpd = feel * adj        return (collided, collisionDir)